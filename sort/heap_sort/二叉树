二叉树的基本性质

节点的度：节点的子节点的数量为该节点的度。在完全二叉树中，节点的度最多为2，最少为0。
叶子节点：度为0的节点称为叶子节点。
假设完全二叉树的总结点树为n（类比成待排序的序列长度为n），度为0的节点数量为n0，度为1的节点数量为n1，度为2的节点数量为n2,则显然满足n=n0+n1+n2。

性质1:二叉树第i层上的结点数目最多为2^(i-1),(i≥1)。

性质2:深度为k的二叉树至多有(2^k)-1个结点(k≥1)。 n=2^0+2^1+…+2^(k-1)=(2^k)-1故命题正确。

性质3 在任意-棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则no=n2+1。


完全二叉树的性质

性质1： 当n为偶数时，n1=1，n为奇数时，n1=0。(n1:度为1的节点数)
性质2：具有n个节点的完全二叉树的深度为k=[log2(n)]（向上取整）。 (二叉树最小深度是1，节点只有一个的二叉树深度是1)
性质3：对一颗具有n个节点的完全二叉树中的节点从1开始按层序编号，则对于任意的编号为i（1<= i <=n的节点：
(1) 如果i=1,则节点i是根节点，无双亲。
(2) 如果i>1,则节点i的双亲节点为[i/2](向下取整)
(3) 如果2i<=n，则i的左孩为2i，如果2i>n，则i无左孩
(4) 如果2i+1<=n,则i的右孩为2i+1，否则i无右孩




"""
        堆排序
        堆介绍
            本质是特殊的完全二叉树[若设二叉树的深度为h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树]，
            完全二叉树节点的度（子节点数），节点的度最多为2，最少为0
            叶子节点：度为0的节点称为叶子节点
            比较重要的性质是，任意的子节点小于（或者大于）其所有的父节点，堆分成大顶堆和小顶堆
            大顶堆：父节点大于子节点，左右节点没有要求
            小顶堆：父节点小于子节点，左右节点没有要求
        算法思想
            1.首先将要排序的序列构建成大顶堆（有意思，怎么构建），也就是说，位于根节点的元素，必然是序列中最大的值
            2.将根节点的与元素与序列的最后一个元素进行交换，这样最大的值就已经排到了序列最后一位
            3.对交换后的前n-1个值进行调整，使其重新构建成大顶堆
            4.重复2&3，直至堆中只有一个元素为止
        所以重点是，怎么将一个随意的序列，排成一个大顶堆
        """

        # -------------------------堆排序--------------------------------
        # **********获取左右叶子节点**********
        def LEFT(i):
            return 2 * i + 1

        def RIGHT(i):
            return 2 * i + 2

        # ********** 调整大顶堆 **********
        # nums:待调整序列 length: 序列长度 i:需要调整的结点
        def adjust_max_heap(nums, length, i):
            # 定义一个int值保存当前序列最大值的下标
            largest = i
            # 执行循环操作：两个任务：1 寻找最大值的下标；2.最大值与父节点交换
            while True:
                # 获得序列左右叶子节点的下标
                left, right = LEFT(i), RIGHT(i)
                # 当左叶子节点的下标小于序列长度 并且左叶子节点的值大于父节点时，
                # 将左叶子节点的下标赋值给largest
                if (left < length) and (nums[left] > nums[i]):
                    largest = left
                # 当右叶子节点的下标小于序列长度 并且右叶子节点的值大于父节点时，
                # 将右叶子节点的下标值赋值给largest
                if (right < length) and (nums[right] > nums[largest]):
                    largest = right
                # 如果largest不等于i 说明当前的父节点不是最大值，需要交换值
                if largest != i:
                    temp = nums[i]
                    nums[i] = nums[largest]
                    nums[largest] = temp
                    i = largest
                else:
                    break

        # ********** 建立大顶堆 **********
        def build_max_heap(nums):
            length = len(nums)
            for x in range(length // 2, -1, -1):
                adjust_max_heap(nums, length, x)

        # ********** 堆排序 **********
        def heap_sort(nums):
            # 先建立大顶堆，保证最大值位于根节点；并且父节点的值大于叶子结点
            build_max_heap(nums)
            # i：当前堆中序列的长度.初始化为序列的长度
            length = len(nums)
            # 执行循环：1. 每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...)
            #         2. 调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度
            while length > 0:
                temp = nums[length - 1]
                nums[length - 1] = nums[0]
                nums[0] = temp
                # 堆中序列长度减1
                length -= 1
                # 调整大顶堆
                adjust_max_heap(nums, length, 0)
            return nums
